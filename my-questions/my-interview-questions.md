# Вопросы к собесу:
## Общее:
### Расскажи про свой опыт?
___
## Java
### Объясни public static void main(String[] args)
psvm - это точка входа Java-программы для виртуальной машины Java (JVM).
- `public`- чтобы JVM имела к нему доступ
- `static`- потому что JVM не умеет создавать экземпляры классов. JVM вызывает <ClassName>.<mainMethod>
- `void` - JVM не ожидает значения от main(). Если другой тип возвращаемого значения, то RunTimeError i.e., NoSuchMethodFoundError.
- `(String[] args)`. JVM вызывает main() передавая аргументы (типа String) командной строкой

### В чем особенность Generics?
Они существуют только в compile-time для сохранения обратной совместимости. Во время runtime generic-тип сводится либо к Object,
если сам параметр (например `Т`) не наследуется ни от какого класса, либо к родительскому классу.

### Расскажи про отличия Абстрактного класса от интерфейса?

### Если бы в Java не было множественного наследования через интерфейсы, то к какой проблеме это бы привело?
Интерфейсы бы раздувались до больших размеров, и нарушался бы Interface segregation principal

### Обработка исключений
1. try/catch
2. try/catch+finally. finally{} выполнится всегда, кроме случаев когда:
- в самом блоке finally вылетает ошибка
- вызывается метод System.exit()
- операционная система завершит работу JVM
- Если блок finally будет выполняться потоком демона, а все остальные потоки не демоны завершат свое выполнение

### GC в Java? Какой по дефолту? Какой общий принцип действия? roots?
GC roots: static, class, thread, объекты со стека

### Объясни стримы? Для чего можно использовать flatMap?
???

### List.of()
Возвращает иммутабельную коллекцию, у которой всё равно можно вызвать метод add(), который выбросит UnsupportedOperationException, что нарушает Liskov substitution principle
### Если в методе создам локальную int x=5 и на следующей строке буду использовать его в стриме в лямбде, что будет?

### Объясни Java record?
Он final
#### В чем минус?
- сложно использовать cо SpringData

## Multithreading

#### Deadlock
Deadlock, или взаимная блокировка, возникает, когда есть несколько потоков и каждый ожидает ресурс,
принадлежащий другому потоку, так что формируется цикл из ресурсов и ожидающих их потоков.
Наиболее очевидным видом ресурса является монитор объекта, но любой ресурс, который вызывает блокировку (например,`wait/notify`), также подходит.
#### Livelock и потоковое голодание
Livelock возникает, когда потоки тратят все свое время на переговоры о доступе к ресурсу или обнаруживают и избегают тупиковой ситуации так,
что поток фактически не продвигается вперед. Голодание возникает, когда потоки сохраняют блокировку в течение длительных периодов,
так что некоторые потоки «голодают» без прогресса.

#### RaceCondition
Состояние гонки возникает, когда один и тот же ресурс используется несколькими потоками одновременно,
и в зависимости от порядка действий каждого потока может быть несколько возможных результатов.
___
## Spring
### Что такое Бин?
### Какие знаешь контейнеры бинов? 
### Какие есть способы объявить бин?

### Способы внедрить зависимость? В чем отличие?
1. на поле через @Autowired
2. через конструктор
3. через сеттер (над методом)
- Через конструктор мы можем поменять DI фреймворк и функционал останется
- через @Autowired будет задействована рефлексия
- Однако если через ломбоковский конструктор (@RequiredArgs) делать внедрение, то если бина нет в контексте мы этого просто не заметим.
  Это является преимуществом использования @Autowired

### Кто вызывает методы контроллера ?
Dispatcher Servlet
### Отличие аннотаций `@Component` `@Controller` `@RestController` `@Service` `@Repository` ?
@Controller (@RestController) говорит спрингу исследовать данный класс на наличие аннотации @RequestMapping. Другие стереотипные аннотации такого не делают
#### А семантическая разница?

## @Transactional

### `@Transactional` где нужно использовать?
Не на все методы. Например, на методы которые просто читают из базы нет необходимости вешать @Transactional. 
Однако можно readonly = true поставить у транзакции которая читает что-то из сложной структуры таблиц

### Как можно решить эту проблему? Варианты решения: селф-инжект, TransactionalManager, Facade
```java
@Service
@RequiredArgsConstructor
public class TestService{

    private final TestRepository repository;
    private final TestEventPublisher eventPublisher;

    @Transactional
    public void test1(){
        repository.save(new Test());
        test2();
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW) // для начала без
    public void test2(){
        eventPublisher.sendEvent("Test saved");
    }
}
```
## Паттерны МСА
### Transactional outbox. Дан код. Как обеспечить согласованность данных между операциями?

```java
@Service
@RequiredArgsConstructor
public class TestFacade {
 
    private final TestService service;
 
    public void create(Order order) {
        service.test1();
        //
        service.test2();
    }
}
```

### Паттерн Circuit breaker
Ситуация: Один МС делает регулярные запросы во второй МС, а тот в свою очередь выполняя долгие расчёты отвечает первому. В один момент второй МС падает и начинает тем самым блокировать работу первого, ведь он продолжает слать запросы ко второму и ждать ответ. Как решить данную проблему?
Ответ: Hystrix
___
## Hibernate
### Как можно улучшить код:
```java
for(int i=0, i<objectList.size(), i++){
repository.save(objectList.get(i))
}
```

```java
objectList.forEach(repository::save) // хибернейт сам может циклический INSERT мержить в 1 запрос (batchSize)
```

```java
repository.saveAll(objectList)
```

### Объясни N+1
### Уровни изолированности БД
### Какой уровень по умолчанию в postgres
Read Committed
### Если в транзакционном методе сначала вызвать repository.save(obj), а в след строке obj.setName == "newName", то что сохраниться в БД?
В Hibernate персистентность происходит при закрытии транзакции, так что сохранится obj с полем name = "newName"   
### SQL-инъекции?
Инъекции возможны при использовании старых технологий. Например, JDBC Statement где не происходило экранирования запроса.
#### Пример: 
запрос `"SELECT * FROM Users WHERE name='{name}'"`, где `name` принимается из запроса по REST в какой-нибудь форме поиска. 
Тогда, в поле `name` при поиске можно было вбить `'; DELETE FROM Users WHERE name != '` и этот запрос отработает в БД, удалив все записи из таблицы `User`, при условии, что у таблицы есть поле `name`  
В дальнейшем технологии (JDBC PreparedStatement, Hibernate) научились экранировать все запросы и получалось `\\' ; DELETE FROM Users WHERE name !='\\` или использовать свой API для работы с запросами
### Индексы БД. Когда применяем, когда избегаем?
### почему данный запрос не годится для работы на проде? и как его нужно переделать?
```sql
SELECT
call_id, process_log_id, phase
FROM
PROCESS_LOG
WHERE
lower(status)='running'
```

ответ:
1. Не использовать lower, тк наш sql сервер не case-sensitive
2. Приводить на стороне кода к общему регистру, чтобы потом не редьюсить производительность БД
3. Лучше сделать через LIKE, тк он быстрее за счет возможности использования индексов

### Способы масштабирования БД? (Партицирование, шардинг, репликация) 
### Пагинация. Какие есть виды? (обычная и seek) В чём разница? Какой вид применяем в той или иной ситуации? 
### Разница между GET и POST запросом? (вопрос про возможность наличия body у GET)
___

ДОБАВИТЬ ВОПРОСЫ ПО КАФКЕ
___
## Паттерны
### Паттерны: какие есть виды паттернов?
### Назови 3 паттерна которые чаще всего используешь?
### В чем преимущества и недостатки монолита и микросервисной архитектуры?
### Паттерны МСА?
___
## Ситуации
### Ситуация: ты приходишь на новый проект, тебе выдают все доступы, но при сборке проекта мавеном у тебя не проходит часть артефактов. Твои действия?
- Взять у коллег файл `setting.xml`
### Как при сборке заигнорить тесты?
- `mvn -Dskip.test`
### Можно ли использовать версию библиотеки latest?
### Ты ревьвишь ПР и видишь что коллега тестирует логику валидатора создавая на каждый кейс новый тестовый метод. Твои предложения?
___
## Рефакторинг
```java
@Service
@RequiredArgsConstructor
public class ConfirmDocServiceImpl implements ConfirmDocService {

    private final ConfirmDocMapper confirmDocMapper;
    private final ConfirmDocRepository confirmDocRepository;
    private final ConfirmDocStateMachineService confirmDocStateMachineService;
    private final StateMachineFactory<DocStatusState, DocStatusEvent> confirmDocStateMachineFactory;
    
    @Override
    @Transactional
    public ConfirmDocDto createConfirmDoc(ConfirmDocDto confirmDocDto) {
        ConfirmDoc confirmDoc = confirmDocMapper.toEntity(confirmDocDto);
        StateMachine<DocStatusState, DocStatusEvent> sm = confirmDocStateMachineFactory.getStateMachine();
        sm.getExtendedState().getVariables().put("CONFIRM_DOC_TO_BE_SAVED", confirmDoc);
        sm.start();
        confirmDoc.setDocStatusId(sm.getState().getId());
        ConfirmDoc savedConfirmDoc = confirmDocRepository.save(confirmDoc);
        return confirmDocMapper.toDto(savedConfirmDoc);
    }
}
```
### Какие проблемы видишь в коде?
Ответ: Нарушение Single Responsibility 
### Предположим, что перед сохранением параметра его нужно провалидировать. Причем валидаций может быть сколько угодно и они могут быть совершенно разными, вплоть до отправки в другой МС части данных. Как бы ты реализовал такую валидацию?
Ответ: Паттерн "chain of responsibility"
### Как обеспечить согласованность данных при ситуации когда с данными работает много пользователей:
Ответ: 
- выстроить в очередь (аналог блокировок из способа обеспечить изолированность транзакций)
- версионность (оттуда же), причем если происходит конфликт версий - сообщать пользователю об этом ???
### Как обеспечить историчность данных?
Ответ: Создать помимо основной таблицы историческую таблицу со ссылкой на основную. Далее в формате одной транзакции записать данные в основную и в историчную таблицу.
### Как реализовать работу с сессиями в МСА? ????? То есть у тебя есть МС который завязан на пользовательские сессии, но "подов" с этим МСом может быть много и фронт сначала может обратиться к одному инстансу, а потом к другому. Последний в свою очередь не знает ничего о сессии
Сессия обычно выносится в отдельное хранилище (чаще распределенное (hazelcast???)), чем обеспечивается stateless сервера (теория из RESTfull)

### Задача.
Компания по продаже товаров и услуг.
Необходимо реализовать логику в сервисе уведомлений. В нашем примере у нас будет топик заказов. OrderMessage (заказ) приходит из кафки.
Мы хотим отправлять разные PUSH уведомления в зависимости от состояния заказа. Рассылка может произойти в одно или несколько мест.
Реализовать одно кастомное уведомление. Если уведомление не было отправлено, его необходимо переотправить.
Аналитики нас предупредили, что в будущем количество различных видов уведомлений будет увеличиваться, при реализации это необходимо предусмотреть.

Пример: если заказ переместился из оплаченного статуса в отмененный и заказ был совершен не более 30 минут назад,
то необходимо отправить уведомление покупателю с информацией о произошедшем событии.

Осовная цель - продемонстрировать свои всесторонние способности.
По задаче можно и нужно задавать вопросы. Комментирование своих шагов приветствуется!